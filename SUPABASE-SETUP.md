# Supabase Authentication Setup Guide

This guide explains how to set up Supabase authentication with Clerk JWT templates in your NextJS application.

## Environment Variables

Create a `.env.local` file in your project root with the following variables:

```env
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project-id.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-from-api-settings
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-from-api-settings

# Clerk Authentication (required for JWT template)
CLERK_SECRET_KEY=your_clerk_secret_key
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_publishable_key
```

## Clerk JWT Template Setup

The token generation relies on a JWT template named 'supabase' in your Clerk dashboard:

1. Log in to your [Clerk Dashboard](https://dashboard.clerk.dev/)
2. Navigate to JWT Templates
3. Create a new template named 'supabase'
4. Configure it with the following claims for Supabase authentication:

```json
{
  "sub": "{{user.id}}",
  "aud": "authenticated",
  "role": "authenticated",
  "exp": "{{config.expireIn}}",
  "user_id": "{{user.id}}",
  "metadata": {
    "role": "{{user.public_metadata.role}}"
  }
}
```

## Supabase Configuration

1. Log in to your [Supabase Dashboard](https://app.supabase.io/)
2. Go to your project settings
3. Navigate to API settings
4. Copy the URL, anon key, and service role key
5. Ensure Row Level Security (RLS) is properly configured

## Debugging Token Issues

If you encounter token generation issues, check the following:

1. Verify the JWT template is correctly named 'supabase' in Clerk dashboard
2. Ensure all environment variables are properly set
3. Check browser console and server logs for specific error messages
4. Verify Clerk session is properly initialized before token requests
5. Check network requests for 401/403 errors indicating auth problems

## Testing Authentication

To test if authentication is working correctly:

1. Log in to your application
2. Open browser developer tools
3. Check the network tab for requests to `/api/supabase/token`
4. Verify the response contains a valid token
5. Confirm Supabase queries work with the authenticated client

## Row Level Security (RLS) Setup Example

This example assumes you have a table named `articles` where you want to restrict access based on the logged-in user. The `owner_id` column should be of type `UUID` and reference `auth.users(id)`.

```sql
-- 1. Create the table
CREATE TABLE public.articles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT,
  owner_id UUID REFERENCES auth.users(id) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- 2. Enable Row Level Security on the table
ALTER TABLE public.articles ENABLE ROW LEVEL SECURITY;

-- 3. Create a policy for SELECT (reading)
-- This policy allows users to read only their own articles.
CREATE POLICY "Users can read their own articles"
ON public.articles FOR SELECT
USING (auth.uid() = owner_id);

-- 4. Create a policy for INSERT (creating)
-- This policy allows users to insert articles for themselves.
CREATE POLICY "Users can create their own articles"
ON public.articles FOR INSERT
WITH CHECK (auth.uid() = owner_id);

-- 5. Create a policy for UPDATE (modifying)
-- This policy allows users to update only their own articles.
CREATE POLICY "Users can update their own articles"
ON public.articles FOR UPDATE
USING (auth.uid() = owner_id);

-- 6. Create a policy for DELETE (removing)
-- This policy allows users to delete only their own articles.
CREATE POLICY "Users can delete their own articles"
ON public.articles FOR DELETE
USING (auth.uid() = owner_id);

```

This setup ensures that all database operations are securely scoped to the authenticated user, relying on Supabase's built-in `auth.uid()` function, which works seamlessly with the Clerk integration.

## Supabase Setup and RLS Guide for LearnFun SL

This document outlines the correct database setup for Row Level Security (RLS) to work seamlessly with the native Clerk.js integration.

### Core Principle

The native Clerk integration automatically creates a "shadow user" in Supabase's `auth.users` table for every Clerk user. This allows us to use the standard `auth.uid()` function in our RLS policies to get the user's unique Supabase ID (`UUID`).

**IMPORTANT**: All tables that have user-owned data must have a column (e.g., `user_id`) of type `UUID` that references `auth.users(id)`.

---

### 1. RLS for User-Owned Content (Decks, Cards, Progress)

Your policies for `decks`, `cards`, and `user_progress` are already correctly implemented. This section documents that correct implementation for clarity.

**Example for `decks` table:**

```sql
-- Enable RLS on the table
ALTER TABLE public.decks ENABLE ROW LEVEL SECURITY;

-- Policy: Users can perform all actions on their own decks.
CREATE POLICY "Users can manage their own decks"
ON public.decks FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
```

**Example for `cards` table (based on deck ownership):**

```sql
-- Enable RLS on the table
ALTER TABLE public.cards ENABLE ROW LEVEL SECURITY;

-- Policy: Users can manage cards within decks they own.
CREATE POLICY "Users can manage cards in their own decks"
ON public.cards FOR ALL
USING (EXISTS (
  SELECT 1 FROM decks WHERE decks.id = cards.deck_id AND decks.user_id = auth.uid()
))
WITH CHECK (EXISTS (
  SELECT 1 FROM decks WHERE decks.id = cards.deck_id AND decks.user_id = auth.uid()
));
```

---

### 2. RLS for Role-Based Access (Admin for Resources)

For your `resources` table, we can improve security and maintainability by using a Postgres function to check for an admin role instead of parsing the JWT directly in the policy.

**Step A: Create a function to get claims from the JWT**

This function safely retrieves a specific claim from the current user's JWT.

```sql
CREATE OR REPLACE FUNCTION get_my_claim(claim TEXT)
RETURNS JSONB
LANGUAGE SQL STABLE
AS $$
  SELECT coalesce(current_setting('request.jwt.claims', true)::jsonb ->> claim, NULL)::jsonb;
$$;
```

**Step B: Create a function to check for the admin role**

This function uses the one above to specifically check if the user has an 'admin' role in their metadata. It expects a `metadata` object in your Clerk JWT template.

```sql
CREATE OR REPLACE FUNCTION is_claims_admin()
RETURNS BOOLEAN
LANGUAGE SQL STABLE
AS $$
  SELECT get_my_claim('metadata')::jsonb->>'role' = 'admin'
$$;
```

**Step C: Update RLS policy for `resources`**

Now, we can use this clean function in our policy.

```sql
-- Policy: Allow public read access to all resources
CREATE POLICY "Resources are publicly viewable"
ON public.resources FOR SELECT
TO anon, authenticated
USING (true);

-- Policy: Allow admins to manage all resources
CREATE POLICY "Admins can manage resources"
ON public.resources FOR ALL
USING (is_claims_admin())
WITH CHECK (is_claims_admin());
```

### 3. Required Clerk JWT Template

To make the `is_claims_admin()` function work, your Clerk JWT template **must** include a `metadata` claim. This is more secure and flexible than using a top-level `user_role` claim.

Navigate to **Clerk Dashboard â†’ JWT Templates** and use this structure for your `supabase` template:

```json
{
  "metadata": {
    "role": "{{user.public_metadata.role}}"
  }
}
```

This assumes you store a user's role (e.g., "admin") in their "Public aMetadata" in the Clerk dashboard. This completes the robust, secure, and maintainable integration.
